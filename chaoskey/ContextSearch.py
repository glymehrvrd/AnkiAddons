# -*- coding: utf-8 -*-# 我的Anki插件# 作者：混沌(youliang@chaoskey.com), http://blog.chaoskey.com# 右键搜索import re,base64import anki,aqtfrom anki.utils import ids2str,splitFields,stripHTML,minimizeHTMLfrom aqt import mwfrom aqt.qt import *from aqt.webview import AnkiWebViewfrom aqt.utils import saveGeom, restoreGeom, getBase, mungeQAfrom anki.sound import playFromText, clearAudioQueuefrom comm import onLoad,onSwitchfrom anki.hooks import addHook,remHookfrom aqt.utils import showInfoclass ContextSearch(QDialog):    def __init__(self,text):        QDialog.__init__(self, None, Qt.Window)        self.setWindowTitle(u"相关卡牌")        self.connect(self, SIGNAL("finished(int)"), self._onPreviewFinished)        vbox = QVBoxLayout()        vbox.setMargin(0)        hbox = QHBoxLayout()        hbox.setMargin(0)        self.modeButton=QPushButton(_("Edit"))        self.modeButton.setToolTip(_("Shortcut: %s")%"Ctrl+E")        self.modeButton.setShortcut("Ctrl+E")        self.connect(self.modeButton, SIGNAL("clicked()"), self._onModeButton)        hbox.addWidget(self.modeButton)        spacerItem = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)        hbox.addItem(spacerItem)        label = QLabel(u"匹配精度")        hbox.addWidget(label)        self.comboBox = QComboBox()        self.comboBox.addItems([u"1）首字段，整体精确匹配",            u"2）首字段，部分精确匹配",            u"3）所有字段，整体精确匹配",            u"4）所有字段，部分精确匹配",            u"5）首字段，模糊匹配",            u"6）所有字段，模糊匹配",            u"7）最松的模糊匹配"])        self.connect(self.comboBox, SIGNAL("currentIndexChanged(int)"), self._onComboIndexChanged)        hbox.addWidget(self.comboBox)        self.numlabel = QLabel(u"成功匹配  张卡片")        hbox.addWidget(self.numlabel)        bbox = QDialogButtonBox()        self._previewPrev = bbox.addButton("<", QDialogButtonBox.ActionRole)        self._previewPrev.setAutoDefault(False)        self._previewPrev.setShortcut(QKeySequence("Left"))        self._previewNext = bbox.addButton(">", QDialogButtonBox.ActionRole)        self._previewNext.setAutoDefault(False)        self._previewNext.setShortcut(QKeySequence("Right"))        self.connect(self._previewPrev, SIGNAL("clicked()"), self._onPreviewPrev)        self.connect(self._previewNext, SIGNAL("clicked()"), self._onPreviewNext)        hbox.addWidget(bbox)        vbox.addLayout(hbox)        self._isPreview=True        self._previewWeb = AnkiWebView()        vbox.addWidget(self._previewWeb)        self.editorArea = QWidget()        self._editor = aqt.editor.Editor(mw, self.editorArea, self)        self.editorArea.hide()        vbox.addWidget(self.editorArea)        self.setLayout(vbox)        restoreGeom(self, "context_search")        self._text=re.sub("(?u)\s+"," ",stripHTML(text).strip())        self.nids=[]        self.matchMode=[]         self._refreshData()    def fieldNames(self):        key_fields = set()        all_fields = set()        for m in mw.col.models.all():            for f in m['flds']:                if f['ord']==0 and f['name'].lower() not in key_fields:                    key_fields.add(f['name'].lower())                if f['name'].lower() not in all_fields:                    all_fields.add(f['name'].lower())        return (list(key_fields),list(all_fields))    def _refreshData(self):        sqlText=re.sub("(?iu)([^a-z0-9\W])",r" \1 ",self._text).strip()        sqlText=re.sub("(?u)\s+"," ",sqlText)        sqlText=re.sub("(?u)\W+","%",sqlText)        regex1=re.escape(self._text)        regex2=re.escape(sqlText).replace("\\%", ".*")         words=re.escape(sqlText).split("\\%")        self._regex="(?iu)(%s)"%")(.*?)(".join(words)        self.repl=""        for i in range(len(words)):            self.repl+="%s<b><i><span style=\"background-color:#aaff00; \">\%d</span></i></b>"%(("\%d"%(2*i) if i!=0 else ""),2*i+1)        self.repl=r"<u>%s</u>"%self.repl        nids1=set()        nids2=set()        nids3=set()        nids4=set()        nids5=set()        nids6=set()        for (id,mid,flds) in mw.col.db.execute("""            select id, mid, flds from notes where flds like ? escape '\\'""",            "%"+sqlText+"%"):            flds = splitFields(flds)            first=True            for fld in flds:                fld=re.sub("(?u)\s+"," ",stripHTML(fld))                if first and re.search("(?iu)^"+regex1+"$", fld):                    self.nids.append(id)                elif first and re.search("(?iu)"+regex1, fld):                    nids1.add(id)                elif not first and re.search("(?iu)^"+regex1+"$", fld):                    nids2.add(id)                elif not first and re.search("(?iu)"+regex1, fld):                    nids3.add(id)                elif first and re.search("(?iu)"+regex2, fld):                    nids4.add(id)                elif not first and re.search("(?iu)"+regex2, fld):                    nids5.add(id)                else :                    nids6.add(id)                first=False        self.matchMode.append(0)        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids1) if nid not in self.nids])        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids2) if nid not in self.nids])        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids3) if nid not in self.nids])        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids4) if nid not in self.nids])        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids5) if nid not in self.nids])        self.matchMode.append(len(self.nids))        self.nids.extend([nid for nid in list(nids6) if nid not in self.nids])        self.numlabel.setText(u"一共匹配到%s张卡牌"%len(self.nids))        self.currIndex=0        self.combIndex=0    def _onComboIndexChanged(self,index):        if index<len(self.matchMode):            if self.currIndex!=self.matchMode[index] and self.matchMode[index]<len(self.nids):                self.currIndex=self.matchMode[index]                if self._isPreview:                    self._renderPreview()                else:                    self._renderEdit()            elif self.combIndex!=index:                self.comboBox.setCurrentIndex(self.combIndex)    def _onModeButton(self):        self._isPreview=not self._isPreview        if self._isPreview:            mw.maybeReset()            self.modeButton.setText(_("Edit"))            self.modeButton.setToolTip(_("Shortcut: %s")%"Ctrl+E")            self.modeButton.setShortcut("Ctrl+E")            self._renderPreview()            self._previewWeb.show()            self.editorArea.hide()            self._previewWeb.setFocus()        else:            self.modeButton.setText(_("Browse"))            self.modeButton.setToolTip(_("Shortcut: %s")%"Ctrl+B")            self.modeButton.setShortcut("Ctrl+B")            self._renderEdit()            self._previewWeb.hide()            self.editorArea.show()            self._editor.web.setFocus()    def show(self):                QDialog.show(self)        if self._isPreview:            self._renderPreview()            self.editorArea.hide()            self._previewWeb.setFocus()        else:            self._renderEdit()            self._previewWeb.hide()    def _updatePreviewButtons(self):        self._previewPrev.setEnabled(not not (self.nids and len(self.nids)>1 and self.currIndex>0))        self._previewNext.setEnabled(not not (self.nids and len(self.nids)>1 and self.currIndex<len(self.nids)-1))    def _renderEdit(self):        if self.nids is None or self.currIndex>=len(self.nids):            self._updatePreviewButtons()            return        n = mw.col.getNote(self.nids[self.currIndex])        self._editor.setNote(n)    def _renderPreview(self):        if self.nids is None or self.currIndex>=len(self.nids):            txt = _("(no matching data)")            self._previewWeb.stdHtml(txt)            self._updatePreviewButtons()            return        cid=mw.col.db.scalar("select id from cards where ord=0 and nid = ?", self.nids[self.currIndex])        if not cid:            txt = _("Empty cards found. Please run Tools>Empty Cards.")            self._previewWeb.stdHtml(txt)            self._updatePreviewButtons()            return        for i in range(len(self.matchMode)-1):            if self.currIndex>=self.matchMode[i] and self.currIndex<self.matchMode[i+1]:                if i!=self.comboBox.currentIndex():                    self.combIndex=i                    self.comboBox.setCurrentIndex(i)                break        self._updatePreviewButtons()        c = mw.col.getCard(cid)        txt = c.a()        txt = re.sub("\[\[type:[^]]+\]\]", "", txt)        txt = re.sub("<img *src=[\"'][^<>]+[\"'] */? *>|\[sound:[^\[\]]+?\]", lambda m:"[base64:%s]"%base64.encodestring(m.group(0)) , txt)        txt = re.sub(self._regex,self.repl,txt)        txt = re.sub("\[base64:([^\[\]]+)\]", lambda m:base64.decodestring(m.group(1)) ,txt)        ti = lambda x: x        base = getBase(mw.col)        self._previewWeb.stdHtml(            ti(mungeQA(mw.col, txt)), mw.reviewer._styles(),            bodyClass="card card%d" % (c.ord+1), head=base,            js=anki.js.browserSel)        clearAudioQueue()        if mw.reviewer.autoplay(c):            playFromText(txt)    def _onPreviewPrev(self):        self.currIndex-=1        if self._isPreview:            self._renderPreview()        else:            self._renderEdit()    def _onPreviewNext(self):        self.currIndex+=1        if self._isPreview:            self._renderPreview()        else:            self._renderEdit()    def _onPreviewFinished(self, ok):        saveGeom(self, "context_search")        #mw.progress.timer(10, self._onClosePreview, False)contextPreview=Nonedef closePreview():    global contextPreview    if contextPreview:        contextPreview.close()        contextPreview=Nonedef slotContextSearch(text):    closePreview()    global contextPreview    contextPreview=ContextSearch(text)    contextPreview.show()# 添加右键搜索菜单def addSearchAction(self, menu):    selectedText=self.selectedText()    if selectedText and len(selectedText.strip())>1:        p=menu.addAction(u"相关卡牌")        p.connect(p, SIGNAL("triggered()"), lambda text=selectedText:slotContextSearch(text))def load():    addHook("AnkiWebView.contextMenuEvent", addSearchAction)def unload():    remHook("AnkiWebView.contextMenuEvent", addSearchAction)################################################################# 本模块的信息ModuleInfo = {'name': u'右键搜索'}plugName=os.path.basename(__file__).replace(".py", "")# 添加功能开关action=QAction(ModuleInfo["name"], mw)action.setCheckable(True)action.connect(action, SIGNAL("triggered()"),lambda:onSwitch(load,unload,action,plugName))ModuleInfo.update({"action":action})# 功能加载onLoad(load,action,plugName)