# -*- coding: utf-8 -*-# 我的Anki插件# 作者：混沌(youliang@chaoskey.com), http://blog.chaoskey.com# 视频支持模块import re,os,sys,timefrom aqt import mwfrom aqt.qt import *from anki.cards import Cardfrom aqt import editorfrom aqt.editor import Editorimport forms as formsfrom comm import wrap,studyMode,readMode,onLoad,onSwitch# 启用插件支持oldPluginsEnabled = QWebSettings.globalSettings().testAttribute(QWebSettings.PluginsEnabled)# 将swf标签替换成html格式# 之所以依然采用[sound:#####]的形式，是因为服务端代码不受我控制，并且仅识别<img src="#####">和[sound:#####]作为媒体文件_swfReg="\[sound:(.*?\.swf)\]"_videoReg="\[sound:(.*?\.(avi|ogv|mpg|mpeg|mov|mp4|mkv|ogx|ogv|oga|flv))\]"_swfRepl='<div><object type="application/x-shockwave-flash" data="\\1" width="80%" height="80%"/></div>'_videoRepl='<div><object type="application/x-qt-plugin" classid="mplayer" data="\\1" width="80%" height="80%"/></div>'oldCardQ=Card.qdef newCardQ(_old,self,reload=False,browser=False):    qText=_old(self,reload,browser)    qText=re.sub(_swfReg,_swfRepl,qText)    qText=re.sub(_videoReg,_videoRepl,qText)    return qTextoldCardA=Card.adef newCardA(_old,self):    aText=_old(self)    aText=re.sub(_swfReg,_swfRepl,aText)    aText=re.sub(_videoReg,_videoRepl,aText)    return aText# 暂时将视频和图片归一类（共同点是添加后不需要立刻播放）oldPics=editor.picsnewPics=[r for r in editor.pics]newPics.extend(["swf","avi","ogv","mpg","mpeg","mov","mp4","mkv","ogx","ogv","oga","flv"])# 原函数如果返回的是图片格式<img src="###.swf">，则改成[sound:###.swf]# 之所以依然采用[sound:#####]的形式，是因为服务端代码不受我控制，并且仅识别<img src="#####">和[sound:#####]作为媒体文件oldEditorAddMedia = Editor._addMediadef newEditorAddMedia(_old,self, path, canDelete=False):    html=_old(self, path, canDelete)    return re.sub('<img src="([^"]+\.(swf|avi|ogv|mpg|mpeg|mov|mp4|mkv|ogx|ogv|oga|flv))">','[sound:\\1]',html)# -------------------MPlayer插件------------------------------------------------------------# 视频播放进程启动参数mplayerVideoCmd=["mplayer.exe","-ao","win32","-quiet","-noautosub","-slave", "-idle","-vo","direct3d","-wid"]# MPlayer播放窗口class MPlayerForm(QWidget):        def __init__(self,path=None,parent=None):        QWidget.__init__(self, parent)        self.frm=forms.MPlayerForm.Ui_mplayerForm()        self.frm.setupUi(self)                self.path=path        self.muted=0        self.paused=False        self.openPlayer()                self.playPlayer()        self.timer=QTimer()        self.timer.connect(self.timer, SIGNAL("timeout()"), self.onTimeout)        self.timer.start(1000)        self.currMplayer.connect(self.currMplayer, SIGNAL("readyReadStandardOutput()"), self.onBackMessage)    # 定时获取播放进度    def onTimeout(self):        if self.paused:            return        self.currMplayer.write("get_percent_pos\n")    # 命令响应消息回显    def onBackMessage(self):        while self.currMplayer.canReadLine():            message=self.currMplayer.readLine()            message=str(message)            kv=message.split("=")            if len(kv)>1 and kv[0]=="ANS_PERCENT_POSITION":                self.frm.seekSlider.setValue(int(kv[1]))    # 打开视频播放器    def openPlayer(self):        self.currMplayer=QProcess()        self.currMplayer.setProcessChannelMode(QProcess.MergedChannels)        cmd=mplayerVideoCmd+[str(int(self.frm.mplayerFrame.winId()))]        self.currMplayer.start(cmd[0],cmd[1:])        self.currMplayer.waitForStarted()        # 播放视频    def playPlayer(self):        self.paused=False        if os.path.exists(self.path):            if self.currMplayer==None:                self.openPlayer()            self.path=self.path.replace("\\", "/")            #self.path = self.path.encode(sys.getfilesystemencoding())            self.currMplayer.write('loadfile "%s" 1\n'%self.path)            self.frm.volumeSlider.setValue(50)    # 暂停    def pausePlayer(self):        self.paused=not self.paused                    self.currMplayer.write("pause\n")    # 停止        def stopPlayer(self):        self.currMplayer.write("stop\n")    # 静音    def mutePlayer(self):        self.muted=(self.muted+1)%2        self.currMplayer.write("mute %d\n"%self.muted)    # 关闭视频播放器    def closePlayer(self):        self.timer.stop()        if self.currMplayer:            self.currMplayer.write("quit\n")            self.currMplayer.waitForFinished()        self.currMplayer=None    # 播放进度控制    def seekSliderMoved(self,value):        self.currMplayer.write("seek %d 1\n"%value)    # 音量控制    def volumeSliderMoved(self,value):        self.currMplayer.write('volume %d 1\n'%value)fs=[]# 自定义可嵌入webkit引擎页面的mplayer播放插件def AnkiWebPageCreatePlugin(self, classid, url, paramNames, paramValues):    if classid=="mplayer":        path=None        if url:            path=os.path.split(url.path())[1]        f=MPlayerForm(path,self.view())        global fs        fs.append(f)        return f    return Nonedef mwClose(force=False):    global fs    for f in fs:        f.closePlayer()    fs=[]# Anki退出处理mw.onClose=wrap(mw.onClose, mwClose,pos="before")# 插件装载def load():    QWebSettings.globalSettings().setAttribute(QWebSettings.PluginsEnabled, True)    Card.q = wrap(Card.q, newCardQ,pos="replace")    Card.a = wrap(Card.a, newCardA,pos="replace")    editor.pics=tuple(newPics)    Editor._addMedia = wrap(Editor._addMedia, newEditorAddMedia,pos="replace")    studyMode.web.page().createPlugin=lambda classid, url, paramNames, paramValues,self=studyMode.web.page(): AnkiWebPageCreatePlugin(self,classid, url, paramNames, paramValues)    readMode.web.page().createPlugin=lambda classid, url, paramNames, paramValues,self=readMode.web.page(): AnkiWebPageCreatePlugin(self,classid, url, paramNames, paramValues)# 插件卸载载def unload():    QWebSettings.globalSettings().setAttribute(QWebSettings.PluginsEnabled, oldPluginsEnabled)        mwClose()    Card.q = oldCardQ    Card.a = oldCardA    editor.pics = oldPics    Editor._addMedia = oldEditorAddMedia    studyMode.web.page().createPlugin=None    readMode.web.page().createPlugin=None# 本模块的信息ModuleInfo = {'name': u'视频支持'}plugName=os.path.basename(__file__).replace(".py", "")# 添加功能开关action=QAction(ModuleInfo["name"], mw)action.setCheckable(True)action.connect(action, SIGNAL("triggered()"),lambda:onSwitch(load,unload,action,plugName))ModuleInfo.update({"action":action})# 功能加载onLoad(load,action,plugName)