# -*- coding: utf-8 -*-# 我的Anki插件# 作者：混沌(youliang@chaoskey.com), http://blog.chaoskey.com# 任务管理及提醒import os,sys,random,loggingfrom time import time,strftime,localtimefrom aqt import mwfrom aqt.addcards import AddCardsfrom aqt.studydeck import StudyDeckfrom aqt.models import Modelsfrom aqt.fields import FieldDialogfrom aqt.qt import *from aqt.utils import showInfofrom anki.consts import NEW_CARDS_LAST,NEW_CARDS_FIRSTfrom comm import wrap,studyMode,readMode,speaker,defaultVoice,onLoad,onSwitchcurpath=os.path.dirname(os.path.realpath(__file__))# 数据库文件logfile = os.path.join(curpath, "Warner.log").decode(sys.getfilesystemencoding())logging.basicConfig(filename=logfile,level=logging.INFO,format='%(asctime)s %(message)s', datefmt='%Y/%m/%d %H:%M:%S')# 当没有可复习的卡牌时，故意抛出异常，并在studyMode.nextCard（即mw.reviewer.nextCard）中接受def newGetNewCard(_old):    global taskSched    if already() and taskSched.state==1:        check=taskSched.checkState()        if check :            raise Exception("needJump")    return _old()# 接受mw.col.sched._getNewCard中故意抛出的异常def newNextCard(_old):    try:        return _old()    except Exception as ex:        if ex.message not in ["needJump"]:            raise ex        return None# 关键变量必须都存在，才表示Anki已经启动def already():    return hasattr(mw,"col") and hasattr(mw.col,"conf") and mw.col.conf \            and hasattr(mw.col,"sched") and mw.col.sched \            and hasattr(mw.col,"db") and mw.col.db \            and mw.state != "sync"# 统计各牌组(牌组树的叶端)的到期卡牌#   包括“到期学习卡牌”和“到期复习卡牌”#   不包括"新卡牌"和“提前复习卡牌”def statDueCard():    stat=mw.col.db.all('''        select did,sum(num),sum(pnum) from (            select id,did,left/1000 as num,0 as pnum from cards where queue=1 and due < :cutoff and due < :dayCutoff        UNION            select id,did,1 as num,1 as pnum from cards where queue=2 and due <= :today        UNION            select id,did,1 as num,0 as pnum from cards where queue=3 and due <= :today        )  group by did        ''',cutoff=int(time()),dayCutoff=mw.col.sched.dayCutoff,today=mw.col.sched.today)    dues=[]    for s in stat:        did=s[0]        lim = mw.col.sched._deckRevLimitSingle(mw.col.decks.get(did, False))        num=s[1]-max(0,s[2]-lim)        if num>0:            dues.append((did,num))    return duesdef addTaskModel(col):    mm = col.models    m = mm.new(_("Scheduled Tasks"))    fm = mm.newField(_("Task Name"))    mm.addField(m, fm)    fm = mm.newField(_("Task Detail"))    mm.addField(m, fm)    fm = mm.newField(_("Task Arrangement "))    mm.addField(m, fm)    t = mm.newTemplate(_("Scheduled Tasks"))    t['qfmt'] = "{{"+_("Task Name")+"}}"    t['afmt'] = "{{FrontSide}}\n\n<hr id=answer>\n\n"+"<div style='font-family: Arial; font-size: 20px;' align = left>{{"+_("Task Detail")+"}}</div>"    mm.addTemplate(m, t)    mm.add(m)    return mdef sec2str(sec):    d=sec/(60*60*24)    h=(sec-d*60*60*24)/(60*60)    m=(sec-d*60*60*24-h*60*60)/60    s=sec-d*60*60*24-h*60*60-m*60    rs=""    if d>0:        rs+=u"%d天"%d    if h>0:        rs+=u"%d小时"%h    if m>0:        rs+=u"%d分"%m    rs+=u"%d秒"%s    return rs# 任务调度核心类class TaskScheduler():    def __init__(self):        # 定时器:        #     首先定时检测Anki是否完全启动，一旦启动则启动本插件功能，并检测学习状态，然后进入对应状态        #     如果进入的是“复习状态”，则停止定时器        #     如果进入的是“任务状态”后，则每隔１小时检测一次学习状态，然后进入对应状态        self.timer=QTimer()        # 定时间隔        self.initInterval=5 #　启动是否完成的检测间隔：１秒        self.taskInterval=3600 # 任务块的最大运行间隔：１小时        # 本插件的当前状态：0-表示初始状态;1-表示卡牌复习状态;2-表示新卡牌学习状态;3-表示常规任务状态        self.state=0        # 任务牌组id        self.taskdid=None        # 任务卡牌记录类型id        self.taskmid=None        # 任务列表        self.tasks=None        # 时间戳        self.timestamp=None        # 上一次常规任务        self.task_oldnid=None        # Anki启动后进入第一个任务的标记        self.firstTask=True        # 给“新卡牌学习任务”赋予一个虚拟的nid        self.newCardID=1111111111111L        self.oldGetNewCard=None        self.oldNextCard=None        self.paused=False        self.pauseTime=None    def start(self):        self.timer.connect(self.timer, SIGNAL("timeout()"), self._onStart)        self.timer.start(self.initInterval*1000)    def stop(self,force=False):        logging.info(u'退出任务调度！')        logging.info('--------------------------')        self._saveRunTime()        if self.oldNextCard:            studyMode.nextCard=self.oldNextCard        if self.oldGetNewCard:            mw.col.sched._getNewCard=self.oldGetNewCard        self.timer.disconnect(self.timer, SIGNAL("timeout()"), self.checkState)        self.timer.stop()        self.state=0        self.taskdid=None        self.taskmid=None        self.tasks=None        self.timestamp=None        self.task_oldnid=None        self.firstTask=True        self.oldGetNewCard=None        self.oldNextCard=None        self.paused=False        self.pauseTime=None    def _onStart(self):        if not already():            return        # 定时器目标切换        self.timer.disconnect(self.timer, SIGNAL("timeout()"), self._onStart)        self.timer.stop()        self.timer.connect(self.timer, SIGNAL("timeout()"), self.checkState)        # 插件功能初始化        self._bind()        # 检测学习状态        self.checkState()    # 插件功能初始化    def _bind(self):        # Anki代码接管        self.oldNextCard=studyMode.nextCard        self.oldGetNewCard=mw.col.sched._getNewCard        studyMode.nextCard=wrap(studyMode.nextCard,newNextCard,pos="replace")        mw.col.sched._getNewCard=wrap(mw.col.sched._getNewCard,newGetNewCard,pos="replace")        # 计划任务牌组        self.taskdid=mw.col.conf.get('taskdid')        if self.taskdid is None or mw.col.decks.get(self.taskdid, False) is None:            self.taskdid=mw.col.decks.id(_("Scheduled Tasks"))            mw.col.conf['taskdid']=self.taskdid            mw.col.flush()        # 计划任务卡牌记录类型        self.taskmid=mw.col.conf.get('taskmid')        if self.taskmid is None or mw.col.models.get(self.taskmid) is None:            m=addTaskModel(mw.col)            self.taskmid=m.get('id')                        mw.col.conf['taskmid']=self.taskmid            mw.col.flush()        # 计划任务列表        self.tasks=mw.col.db.all('''            select notes.id,notes.flds from cards,notes where cards.did=? and cards.ord=0 and cards.nid=notes.id        ''',self.taskdid)        self.tasks=[[nid]+flds.split("\x1f") for nid,flds in self.tasks]        self.tasks=[(item[0],item[1],int(round(float(item[3])))) for item in self.tasks]        self.tasks.append((self.newCardID,u'新卡牌学习',(100-sum([item[2] for item in self.tasks]))))        # 计划任务的参考平衡        taskBalance=mw.col.conf.get('taskBalance',{})        _start=False #是否要对taskBalance进行初始化的标记        for t in self.tasks:            if taskBalance.get(str(t[0]),0)==0:                _start=True                break        if _start:            taskBalance={}            for t in self.tasks:                taskBalance[str(t[0])]=1            mw.col.conf['taskBalance']=taskBalance            mw.col.conf['startStat']=int(time()) #统计的起始时间            mw.col.flush()    # 学习状态检测    def checkState(self):        if not already():            return False        dues=statDueCard()        # 所有牌组中的到期统计        due=sum([item[1] for item in dues])        # 当前活动牌组中的到期统计        actDue=sum([item[1] for item in dues if item[0] in mw.col.decks.active()])        # 如果没有到期卡牌，则进行任务调度        if due==0:             return self.moveToTask()        # 非复习状态下，发现有到期卡牌，则进入复习状态        if self.state!=1 and due>0:            mw.col.conf['newSpread'] = NEW_CARDS_LAST             self._saveRunTime()            self._notify(u"到期卡牌任务：发现%d张待复习卡牌"%due)            closeStateTip()            self._moveToReview(dues[0][0])            return True        # 复习状态下，当前牌组中没有到期卡牌，则进行牌组间跳转，继续复习        if self.state==1 and due>0 and actDue==0:            self._moveToReview(dues[0][0])            return True        # 表明当前牌组中还有到期卡牌，继续在当前牌组中复习        mw.col.conf['newSpread'] = NEW_CARDS_LAST         return False    def enterCurrTask(self):        if self.state==3:            readMode.readType="task"            readMode.readLimit=-1            mw.reviewer=readMode            mw.col.decks.select(self.taskdid)            mw.col.startTimebox()            mw.moveToState("review")    # 进入常规任务模式，或新卡牌学习模式    def moveToTask(self,newForce=False):        if not already():            return False        ret=False        task_nid,task_name,run_time=self._choiceTask(newForce)        showStateTip(task_name)        if task_nid!=self.newCardID:            # 常规任务            if self.state!=3 or self.task_oldnid!=task_nid:                self._notify(u"常规任务:%s%s"%(task_name,u"(上次运行过%s,接着运行)"%sec2str(run_time) if run_time else ""))            else:                logging.info(u"继续常规任务:%s"%task_name)            self.task_oldnid=task_nid            self.state=3            readMode.readType="task"            readMode.readLimit=-1            mw.reviewer=readMode            mw.col.decks.select(self.taskdid)            mw.col.startTimebox()            mw.moveToState("review")            ret=True        else:            mw.col.conf['newSpread'] = NEW_CARDS_FIRST            # 新卡牌学习任务            if self.state!=2:                self._notify(u"新卡牌任务%s"%(u"(上次运行过%s,接着运行)"%sec2str(run_time) if run_time else ""))            else:                logging.info(u"继续新卡牌任务")            self.state=2            self.task_oldnid=None            mw.moveToState("deckBrowser")        # 启动定时器        if not self.timer.isActive() or self.timer.interval()<self.taskInterval*1000 or run_time>0:            self.timer.start((self.taskInterval-run_time)*1000)        return ret    # 进入复习状态    def _moveToReview(self,did):        if not already():            return        # 状态        self.state=1        self.task_oldnid=None        # 根牌组        name=mw.col.decks.nameOrNone(did).split("::")        if len(name)>1:            did=mw.col.decks.id(name[0],create=False)        # 进入可复习牌组        mw.reviewer=studyMode        mw.col.decks.select(did)        mw.col.startTimebox()        mw.moveToState("review")        # 停止定时器        if self.timer.isActive():            self.timer.stop()    # 选取一个任务    def _choiceTask(self,newForce=False):        #如果上一个任务没有执行足够时间，依然执行上一个任务        task_nid,task_name,run_time=self._saveRunTime()        self.timestamp=int(time())        if not newForce and task_nid and run_time<self.taskInterval*(80 if self.firstTask else 95)/100 :            self.firstTask=False            return task_nid,task_name,run_time        # 随机选取一个任务        taskBalance=mw.col.conf.get('taskBalance',{})        if task_nid and task_name and run_time>0:            taskBalance[str(task_nid)]=taskBalance.get(str(task_nid),0)+run_time            mw.col.conf['taskBalance']=taskBalance            mw.col.flush()        total=sum([item[1] for item in taskBalance.iteritems()])        rdist=[]        for t in self.tasks:            s=taskBalance.get(str(t[0]),0)            if total==0 or s*100.0/total<=t[2]:                rdist.extend([(t[0],t[1])]*t[2])        task_nid,task_name=random.choice(rdist)        run_time=0        self._saveRunTime(task_nid,task_name,run_time)        self.firstTask=False        return task_nid,task_name,run_time    # 保持当前任务已运行的时间    def _saveRunTime(self,task_nid=None,task_name=None,run_time=None):        if self.taskdid is None:            return        deck=mw.col.decks.get(self.taskdid)        if task_nid is None or task_name is None or run_time is None:            task_nid=deck.get('task_nid',None)            task_name=deck.get('task_name',None)            run_time=deck.get('run_time',0)            if self.timestamp:                if self.paused:                    run_time+=self.pauseTime-self.timestamp                    self.paused=False                    self.pauseTime=None                else:                    run_time+=int(time())-self.timestamp                deck["run_time"]=run_time                mw.col.decks.update(deck)                mw.col.decks.flush()                self.timestamp=None        else:            deck["task_nid"]=task_nid            deck["task_name"]=task_name            deck["run_time"]=run_time            mw.col.decks.update(deck)            mw.col.decks.flush()        return task_nid,task_name,run_time    # 当前任务暂停/恢复    def pause(self):        if taskSched.state not in [2,3]:            return        deck=mw.col.decks.get(self.taskdid)        task_name=deck.get('task_name',None)        run_time=deck.get('run_time',0)        if not self.paused:            self.pauseTime=int(time())            run_time+=self.pauseTime-self.timestamp            self.timer.setInterval((self.taskInterval-run_time)*1000)            self.timer.stop()            self.paused=True            logging.info(u"暂停“%s”"%task_name)            showStateTip(u"“%s”暂停"%task_name)        else:            deltaTime=int(time())-self.pauseTime            self.timestamp+=deltaTime            self.timer.start()            self.paused=False            self.pauseTime=None            logging.info(u"恢复“%s”，已暂停了%s"%(task_name,sec2str(deltaTime)))            showStateTip(task_name)    # 提醒与日志    def _notify(self,text):        logging.info(text)        speaker.play(u"Anki提醒：%s"%text,defaultVoice)# 启动任务调度taskSched=TaskScheduler()# Anki退出处理mw.onClose=wrap(mw.onClose, taskSched.stop,pos="before")# 快捷键"n"和"P"的处理(任务调度状态下有效)def newKeyPressEvent(_old,evt):    global taskSched    if taskSched.state in [2,3] and unicode(evt.text()) == "n":        taskSched.moveToTask(True)    elif  unicode(evt.text()) == "P":        taskSched.pause()    else:        return _old(evt)mw.keyPressEvent=wrap(mw.keyPressEvent, newKeyPressEvent,pos="replace")# 点击"下一个任务"按钮的处理def newLinkHandler(_old,url):    global taskSched    if url=='navn':        taskSched.moveToTask(True)    else:        return _old(url)readMode._linkHandler=wrap(readMode._linkHandler, newLinkHandler,pos="replace")# 关键运行数据显示def onStat():    global taskSched    if not already() or taskSched is None:        return    dues=statDueCard()    due=sum([item[1] for item in dues])    actDue=sum([item[1] for item in dues if item[0] in mw.col.decks.active()])    strStat=u"<b><font color=\"red\">到期卡牌统计</font></b><br />&nbsp;&nbsp;&nbsp;&nbsp;总的卡牌到期数：%d;&nbsp;&nbsp;当前活动卡牌到期数:%d"%(due,actDue)    deck=mw.col.decks.get(taskSched.taskdid)    task_name=deck.get("task_name",None)    run_time=deck.get("run_time",0)    if taskSched.timestamp and taskSched.paused:        run_time+=(taskSched.pauseTime-taskSched.timestamp)    elif taskSched.timestamp :        run_time+=(int(time())-taskSched.timestamp)    if taskSched.state in [2,3]:        strStat+=u"<br /><br /><b><font color=\"red\">当前任务块运行时间</font></b><br />&nbsp;&nbsp;&nbsp;&nbsp;\"%s\"已运行了%s"%(task_name,sec2str(run_time))        elif taskSched.state==1:        strStat+=u"<br /><br /><b><font color=\"red\">当前任务</font></b><br />&nbsp;&nbsp;&nbsp;&nbsp;\"卡牌复习\""    taskBalance=mw.col.conf.get('taskBalance',{})    total=sum([item[1] for item in taskBalance.iteritems()])    strStat+=u"<br /><br /><b><font color=\"red\">任务实际运行占时比</font></b><table cellspacing=3>"    for t in taskSched.tasks:        s=taskBalance.get(str(t[0]),0)        strStat+=u"<tr><td align=right>%s：</td><td align=right>%5.2f％</td><td align=right>（参考权重%2d％）</td><td align=right>耗时%s</td></tr>"%(t[1],s*100.0/total,t[2],sec2str(s))    strStat+=u"</table>*已经排除了卡牌复习的时间<br />"    strStat+=u"</table>*也不包括当前任务块的运行时间<br />"    strStat+=u"*统计起点:%s"%strftime(u'%Y-%m-%d %H:%M:%S',localtime(mw.col.conf.get('startStat',int(time()))))    showInfo(strStat)statShortcut=QShortcut(QKeySequence("Ctrl+s"), mw)statShortcut.connect(statShortcut, SIGNAL("activated()"), onStat)# 为“计划任务”牌组添加卡牌时，必须选择“计划任务”这个特殊卡牌记录类型，并且添加后会自动挂起对应的卡牌def newAddCardsAddNote(_old,self,note):    global taskSched    if self.deckChooser.selectedId()==taskSched.taskdid and note.mid!=taskSched.taskmid:        showInfo(u"在本牌组中，必须选择\"%s\"作为卡牌记录类型!"%mw.col.models.get(taskSched.taskmid).get('name'))        return None    note=_old(self,note)    if already() and taskSched and taskSched.taskdid in [c.did for c in note.cards()]:        mw.col.sched.suspendCards([c.id for c in note.cards()])    return noteAddCards.addNote=wrap(AddCards.addNote, newAddCardsAddNote,pos="replace")# 禁止将卡牌移入“计划任务”这个特殊牌组def newStudyDeckAccept(_old,self):    global taskSched    curRow=self.form.list.currentRow()    if self.ok.text()==_("Move Cards") and curRow>0 and mw.col.decks.id(self.names[curRow])==taskSched.taskdid:        showInfo(u'禁止将其它牌组的卡牌移到"%s"这个特殊牌组中'%self.names[curRow])        return    _old(self)StudyDeck.accept=wrap(StudyDeck.accept,newStudyDeckAccept,pos="replace")# 禁止删除“计划任务”这个特殊卡牌记录类型，并且同时禁止在该卡牌记录类型中添加或删除字段,禁止改变各字段的位置def newModelsDelete(_old,self):    global taskSched    if self.model.get('id')==taskSched.taskmid:        showInfo(u'禁止删除“%s”这个特殊卡牌记录类型!'%self.model.get('name'))        return    _old(self)Models.onDelete=wrap(Models.onDelete,newModelsDelete,pos="replace")def newFieldAddOrDelete(_old,self):    global taskSched    if self.model.get('id')==taskSched.taskmid:        showInfo(u'禁止在“%s”这个特殊卡牌记录类型中添加或删除字段!'%self.model.get('name'))        return    _old(self)FieldDialog.onAdd=wrap(FieldDialog.onAdd,newFieldAddOrDelete,pos="replace")FieldDialog.onDelete=wrap(FieldDialog.onDelete,newFieldAddOrDelete,pos="replace")def newFieldPosition(_old,self,delta=-1):    global taskSched    if self.model.get('id')==taskSched.taskmid:        showInfo(u'禁止在“%s”这个特殊卡牌记录类型中改变各字段的位置!'%self.model.get('name'))        return    _old(self,delta)FieldDialog.onPosition=wrap(FieldDialog.onPosition,newFieldPosition,pos="replace")# 可拖拽的标签控件class LabelDragable(QLabel):    def __init__(self,msg, parent=None):        self.offset=None        QLabel.__init__(self,"""\<table cellpadding=10><tr><td><img src=":/icons/help-hint.png"></td><td>%s</td></tr></table>"""%msg,parent)        self.setFrameStyle(QFrame.Panel)        self.setLineWidth(2)        self.setWindowFlags(Qt.ToolTip)        p = QPalette()        p.setColor(QPalette.Window, QColor("#feffc4"))        self.setPalette(p)        self.setContextMenuPolicy(Qt.CustomContextMenu)        self.connect(self,SIGNAL("customContextMenuRequested(QPoint)"),self.slotShowContextmenu)    def slotShowContextmenu(self,pos):        global taskSched        contextMenu=QMenu(self)        if taskSched.state!=2 and (mw.state!="review" or (not hasattr(mw.reviewer,"readType")) or (mw.reviewer.readType!="task")):            currTask=contextMenu.addAction(u"回到任务界面")            self.connect(currTask, SIGNAL("triggered()"), self.slotCurrTask)        mText=u"恢复任务" if taskSched.paused else u"暂停任务"        pauseTask=contextMenu.addAction(mText)        pauseTask.setShortcut("Shift+p")        self.connect(pauseTask, SIGNAL("triggered()"), self.slotPauseTask)        hideLabel=contextMenu.addAction(u"隐藏")        hideLabel.setShortcut("Ctrl+h")        self.connect(hideLabel, SIGNAL("triggered()"), self.slotHideLabel)        statTask=contextMenu.addAction(u"任务统计")        statTask.setShortcut("Ctrl+s")        self.connect(statTask, SIGNAL("triggered()"), self.slotStatTask)        contextMenu.exec_(QCursor.pos())    def slotCurrTask(self):        global taskSched        if taskSched.state!=2:            taskSched.enterCurrTask()    def slotPauseTask(self):        global taskSched        taskSched.pause()    def slotHideLabel(self):        if self.isVisible():            self.hide()        else:            self.show()    def slotStatTask(self):        onStat()    def mousePressEvent(self,ev):        if ev.button()==Qt.LeftButton:            self.offset=ev.pos()-self.rect().topLeft()            ev.accept()    def mouseMoveEvent(self,ev):        if ev.buttons()&Qt.LeftButton:            self.move(ev.globalPos()-self.offset)            ev.accept()    def mouseDoubleClickEvent(self, ev):        self.slotCurrTask()# 可拖拽的标签控件实例(确保唯一存在)_stateLabel = Nonedef showStateTip(msg):    global _stateLabel    closeStateTip()    lab = LabelDragable(msg,mw)    lab.show()    lab.move(mw.mapToGlobal(QPoint(mw.width()-lab.width()-30, 60)))    _stateLabel = labdef closeStateTip():    global _stateLabel    if _stateLabel:        try:            _stateLabel.deleteLater()        except:            # already deleted as parent window closed            pass        _stateLabel = NonehideLabelShortcut=QShortcut(QKeySequence("Ctrl+h"), mw)hideLabelShortcut.connect(hideLabelShortcut, SIGNAL("activated()"), lambda :_stateLabel.slotHideLabel() if _stateLabel else None)def load():    taskSched.start()def unload():    taskSched.stop()###########################界面配置####################################### 本模块的信息ModuleInfo = {'name': u'任务调度'}plugName=os.path.basename(__file__).replace(".py", "")# 添加功能开关action=QAction(ModuleInfo["name"], mw)action.setCheckable(True)action.connect(action, SIGNAL("triggered()"),lambda:onSwitch(load,unload,action,plugName))ModuleInfo.update({"action":action})# 功能加载onLoad(load,action,plugName)